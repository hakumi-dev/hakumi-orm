# typed: strict
# frozen_string_literal: true
# GENERATED BY hakumi-orm -- DO NOT EDIT

<%- if module_name -%>
module <%= module_name %>
<%- end -%>
<%= ind %>class <%= relation_class_name %> < ::HakumiORM::Relation
<%= ind %>  extend T::Sig

<%= ind %>  ModelType = type_member {{ fixed: <%= qualified_record_class %> }}

<%= ind %>  sig { override.returns(T.nilable(String)) }
<%= ind %>  def stmt_count_all = '<%= stmt_count_name %>'

<%= ind %>  sig { override.returns(T.nilable(String)) }
<%= ind %>  def sql_count_all = '<%= count_sql %>'

<%= ind %>  sig { void }
<%= ind %>  def initialize
<%= ind %>    super(<%= qualified_schema %>::TABLE_NAME, <%= qualified_schema %>::ALL)
<%- if soft_delete -%>
<%= ind %>    @default_exprs << <%= qualified_schema %>::<%= soft_delete_const %>.is_null
<%- end -%>
<%= ind %>  end
<%- if soft_delete -%>

<%= ind %>  sig { returns(T.self_type) }
<%= ind %>  def with_deleted
<%= ind %>    @default_exprs = []
<%= ind %>    mark_defaults_dirty!
<%= ind %>    self
<%= ind %>  end

<%= ind %>  sig { returns(T.self_type) }
<%= ind %>  def only_deleted
<%= ind %>    @default_exprs = [<%= qualified_schema %>::<%= soft_delete_const %>.is_not_null]
<%= ind %>    mark_defaults_dirty!
<%= ind %>    self
<%= ind %>  end

<%= ind %>  sig { override.params(adapter: ::HakumiORM::Adapter::Base).returns(Integer) }
<%= ind %>  def delete_all(adapter: ::HakumiORM.adapter)
<%= ind %>    compiled = adapter.dialect.compiler.update(
<%= ind %>      table: @table_name,
<%= ind %>      assignments: [::HakumiORM::Assignment.new(<%= qualified_schema %>::<%= soft_delete_const %>, ::HakumiORM::TimeBind.new(::Time.now.utc))],
<%= ind %>      where_expr: combined_where
<%= ind %>    )
<%= ind %>    use_result(adapter.exec_params(compiled.sql, compiled.pg_params), &:affected_rows)
<%= ind %>  end
<%- end -%>

<%= ind %>  sig { override.params(result: ::HakumiORM::Adapter::Result).returns(T::Array[<%= qualified_record_class %>]) }
<%= ind %>  def hydrate(result)
<%= ind %>    <%= qualified_record_class %>.from_result(result)
<%= ind %>  end

<%= ind %>  sig { override.params(records: T::Array[<%= qualified_record_class %>], nodes: T::Array[::HakumiORM::PreloadNode], adapter: ::HakumiORM::Adapter::Base).void }
<%= ind %>  def run_preloads(records, nodes, adapter)
<%= ind %>    nodes.each do |node|
<%- if preloadable_assocs.any? -%>
<%= ind %>      case node.name
<%- preloadable_assocs.each do |assoc| -%>
<%= ind %>      when :<%= assoc[:method_name] %>
<%= ind %>        <%= qualified_record_class %>.preload_<%= assoc[:method_name] %>(records, adapter: adapter)
<%- if assoc[:relation_class] -%>
<%= ind %>        unless node.children.empty?
<%= ind %>          all_children = records.flat_map { |r| r._preloaded_<%= assoc[:method_name] %> || [] }
<%= ind %>          <%= assoc[:relation_class] %>.new.run_preloads(all_children, node.children, adapter) unless all_children.empty?
<%= ind %>        end
<%- end -%>
<%- end -%>
<%= ind %>      else
<%= ind %>        custom_preload(node.name, records, adapter)
<%= ind %>      end
<%- else -%>
<%= ind %>      custom_preload(node.name, records, adapter)
<%- end -%>
<%= ind %>    end
<%= ind %>  end
<%= ind %>end
<%- if module_name -%>
end
<%- end -%>
