# typed: strict
# frozen_string_literal: true
# GENERATED BY hakumi-orm -- DO NOT EDIT

require "bigdecimal"

<%- if module_name -%>
module <%= module_name %>
<%- end -%>
<%= ind %>class <%= record_class_name %>
<%= ind %>  extend T::Sig

<%- columns.each do |col| -%>
<%= ind %>  sig { returns(<%= col[:ruby_type] %>) }
<%= ind %>  attr_reader :<%= col[:name] %>

<%- end -%>
<%- has_many.each do |assoc| -%>
<%= ind %>  sig { returns(T.nilable(T::Array[<%= assoc[:record_class] %>])) }
<%= ind %>  attr_accessor :_preloaded_<%= assoc[:method_name] %>

<%- end -%>
<%- has_one.each do |assoc| -%>
<%= ind %>  sig { returns(T.nilable(T::Array[<%= assoc[:record_class] %>])) }
<%= ind %>  attr_accessor :_preloaded_<%= assoc[:method_name] %>

<%- end -%>
<%- belongs_to.each do |assoc| -%>
<%= ind %>  sig { returns(T.nilable(T::Array[<%= assoc[:record_class] %>])) }
<%= ind %>  attr_accessor :_preloaded_<%= assoc[:method_name] %>

<%- end -%>
<%= ind %>  sig { params(<%= init_sig_params %>).void }
<%= ind %>  def initialize(<%= init_args %>)
<%- columns.each do |col| -%>
<%= ind %>    @<%= col[:name] %> = T.let(<%= col[:name] %>, <%= col[:ruby_type] %>)
<%- end -%>
<%- has_many.each do |assoc| -%>
<%= ind %>    @_preloaded_<%= assoc[:method_name] %> = T.let(nil, T.nilable(T::Array[<%= assoc[:record_class] %>]))
<%- end -%>
<%- has_one.each do |assoc| -%>
<%= ind %>    @_preloaded_<%= assoc[:method_name] %> = T.let(nil, T.nilable(T::Array[<%= assoc[:record_class] %>]))
<%- end -%>
<%- belongs_to.each do |assoc| -%>
<%= ind %>    @_preloaded_<%= assoc[:method_name] %> = T.let(nil, T.nilable(T::Array[<%= assoc[:record_class] %>]))
<%- end -%>
<%= ind %>  end

<%= ind %>  sig { params(result: ::HakumiORM::Adapter::Result, dialect: ::HakumiORM::Dialect::Base).returns(T::Array[<%= record_class_name %>]) }
<%= ind %>  def self.from_result(result, dialect: ::HakumiORM.adapter.dialect)
<%= ind %>    n = result.row_count
<%= ind %>    return [] if n.zero?
<%= ind %>
<%= ind %>    all_rows = result.values
<%= ind %>    rows = ::Array.new(n)
<%= ind %>    i = 0
<%= ind %>    while i < n
<%= ind %>      row = all_rows[i]
<%= ind %>      obj = allocate
<%- columns.each_with_index do |col, ci| -%>
<%= ind %>      obj.instance_variable_set(:@<%= col[:name] %>, <%= cast_lines[ci] %>)
<%- end -%>
<%= ind %>      rows[i] = obj
<%= ind %>      i += 1
<%= ind %>    end
<%= ind %>    rows
<%= ind %>  end

<%- if find_sql -%>
<%= ind %>  SQL_FIND_BY_PK = T.let('<%= find_sql %>', String)
<%= ind %>  STMT_FIND_BY_PK = T.let('<%= stmt_find_name %>', String)

<%= ind %>  sig { params(pk_value: <%= pk_ruby_type %>, adapter: ::HakumiORM::Adapter::Base).returns(T.nilable(<%= record_class_name %>)) }
<%= ind %>  def self.find(pk_value, adapter: ::HakumiORM.adapter)
<%= ind %>    adapter.prepare(STMT_FIND_BY_PK, SQL_FIND_BY_PK)
<%= ind %>    result = adapter.exec_prepared(STMT_FIND_BY_PK, [pk_value])
<%= ind %>    return nil if result.row_count.zero?

<%= ind %>    from_result(result, dialect: adapter.dialect).first
<%= ind %>  ensure
<%= ind %>    result&.close
<%= ind %>  end

<%- end -%>
<%= ind %>  sig { params(expr: ::HakumiORM::Expr).returns(<%= qualified_relation %>) }
<%= ind %>  def self.where(expr)
<%= ind %>    <%= qualified_relation %>.new.where(expr)
<%= ind %>  end

<%= ind %>  sig { params(expr: ::HakumiORM::Expr, adapter: ::HakumiORM::Adapter::Base).returns(T.nilable(<%= record_class_name %>)) }
<%= ind %>  def self.find_by(expr, adapter: ::HakumiORM.adapter)
<%= ind %>    <%= qualified_relation %>.new.where(expr).first(adapter: adapter)
<%= ind %>  end

<%= ind %>  sig { params(expr: ::HakumiORM::Expr, adapter: ::HakumiORM::Adapter::Base).returns(T::Boolean) }
<%= ind %>  def self.exists?(expr, adapter: ::HakumiORM.adapter)
<%= ind %>    <%= qualified_relation %>.new.where(expr).exists?(adapter: adapter)
<%= ind %>  end

<%= ind %>  sig { returns(<%= qualified_relation %>) }
<%= ind %>  def self.all
<%= ind %>    <%= qualified_relation %>.new
<%= ind %>  end

<%= ind %>  sig { returns(T::Hash[Symbol, <%= to_h_value_type %>]) }
<%= ind %>  def to_h
<%= ind %>    {
<%- columns.each_with_index do |col, i| -%>
<%= ind %>      <%= col[:name] %>: @<%= col[:name] %><%= i < columns.length - 1 ? "," : "" %>
<%- end -%>
<%= ind %>    }
<%= ind %>  end

<%= ind %>  sig { params(other: <%= record_class_name %>).returns(T::Boolean) }
<%= ind %>  def changed_from?(other)
<%= ind %>    <%= columns.map { |c| "@#{c[:name]} != other.#{c[:name]}" }.join(" || ") %>
<%= ind %>  end

<%= ind %>  sig { params(other: <%= record_class_name %>).returns(T::Hash[Symbol, T::Array[<%= to_h_value_type %>]]) }
<%= ind %>  def diff(other)
<%= ind %>    h = T.let({}, T::Hash[Symbol, T::Array[<%= to_h_value_type %>]])
<%- columns.each do |col| -%>
<%= ind %>    h[:<%= col[:name] %>] = [@<%= col[:name] %>, other.<%= col[:name] %>] if @<%= col[:name] %> != other.<%= col[:name] %>
<%- end -%>
<%= ind %>    h
<%= ind %>  end

<%= ind %>  sig { params(only: T.nilable(T::Array[Symbol]), except: T.nilable(T::Array[Symbol])).returns(T::Hash[String, <%= as_json_value_type %>]) }
<%= ind %>  def as_json(only: nil, except: nil)
<%= ind %>    h = T.let({}, T::Hash[String, <%= as_json_value_type %>])
<%- columns.each do |col| -%>
<%= ind %>    h["<%= col[:name] %>"] = <%= col[:json_expr] %> unless (only && !only.include?(:<%= col[:name] %>)) || (except&.include?(:<%= col[:name] %>))
<%- end -%>
<%= ind %>    h
<%= ind %>  end
<%- enum_predicates.each do |pred| -%>

<%= ind %>  sig { returns(T::Boolean) }
<%= ind %>  def <%= pred[:method_name] %> = @<%= pred[:column] %> == <%= pred[:enum_class] %>::<%= pred[:const] %>
<%- end -%>
<%- if delete_sql -%>
<%= ind %>  SQL_DELETE_BY_PK = T.let('<%= delete_sql %>', String)
<%- if soft_delete_sql -%>
<%= ind %>  SQL_SOFT_DELETE_BY_PK = T.let('<%= soft_delete_sql %>', String)
<%- end -%>
<%- (has_many + has_one).each do |assoc| -%>
<%= ind %>  SQL_DELETE_<%= assoc[:method_name].upcase %> = T.let('<%= assoc[:delete_sql] %>', String)
<%- end -%>

<%- if soft_delete -%>
<%= ind %>  sig { returns(T::Boolean) }
<%= ind %>  def deleted? = !@<%= soft_delete_attr %>.nil?

<%- end -%>
<%- if has_many.any? || has_one.any? -%>
<%= ind %>  sig { params(dependent: Symbol, adapter: ::HakumiORM::Adapter::Base).void }
<%= ind %>  def delete!(dependent: :none, adapter: ::HakumiORM.adapter)
<%= ind %>    errors = ::HakumiORM::Errors.new
<%= ind %>    <%= record_class_name %>::Contract.on_destroy(self, errors)
<%= ind %>    raise ::HakumiORM::ValidationError, errors unless errors.valid?
<%= ind %>
<%= ind %>    case dependent
<%= ind %>    when :delete_all
<%- (has_many + has_one).each do |assoc| -%>
<%= ind %>      adapter.exec_params(SQL_DELETE_<%= assoc[:method_name].upcase %>, [@<%= assoc[:pk_attr] %>]).close
<%- end -%>
<%= ind %>    when :destroy
<%- has_many.each do |assoc| -%>
<%- if assoc[:target_has_pk] -%>
<%= ind %>      <%= assoc[:method_name] %>.to_a(adapter: adapter).each { |r| r.delete!(adapter: adapter) }
<%- else -%>
<%= ind %>      adapter.exec_params(SQL_DELETE_<%= assoc[:method_name].upcase %>, [@<%= assoc[:pk_attr] %>]).close
<%- end -%>
<%- end -%>
<%- has_one.each do |assoc| -%>
<%- if assoc[:target_has_pk] -%>
<%= ind %>      <%= assoc[:method_name] %>(adapter: adapter)&.delete!(adapter: adapter)
<%- else -%>
<%= ind %>      adapter.exec_params(SQL_DELETE_<%= assoc[:method_name].upcase %>, [@<%= assoc[:pk_attr] %>]).close
<%- end -%>
<%- end -%>
<%= ind %>    end
<%- if soft_delete -%>
<%= ind %>    result = adapter.exec_params(SQL_SOFT_DELETE_BY_PK, [adapter.encode(::HakumiORM::TimeBind.new(::Time.now)), @<%= pk_attr %>])
<%- else -%>
<%= ind %>    result = adapter.exec_params(SQL_DELETE_BY_PK, [@<%= pk_attr %>])
<%- end -%>
<%= ind %>    raise ::HakumiORM::Error, "DELETE affected 0 rows" if result.affected_rows.zero?
<%= ind %>
<%= ind %>    <%= record_class_name %>::Contract.after_destroy(self, adapter)
<%= ind %>  ensure
<%= ind %>    result&.close
<%= ind %>  end
<%- if soft_delete -%>

<%= ind %>  sig { params(dependent: Symbol, adapter: ::HakumiORM::Adapter::Base).void }
<%= ind %>  def really_delete!(dependent: :none, adapter: ::HakumiORM.adapter)
<%= ind %>    errors = ::HakumiORM::Errors.new
<%= ind %>    <%= record_class_name %>::Contract.on_destroy(self, errors)
<%= ind %>    raise ::HakumiORM::ValidationError, errors unless errors.valid?
<%= ind %>
<%= ind %>    case dependent
<%= ind %>    when :delete_all
<%- (has_many + has_one).each do |assoc| -%>
<%= ind %>      adapter.exec_params(SQL_DELETE_<%= assoc[:method_name].upcase %>, [@<%= assoc[:pk_attr] %>]).close
<%- end -%>
<%= ind %>    when :destroy
<%- has_many.each do |assoc| -%>
<%- if assoc[:target_has_pk] -%>
<%= ind %>      <%= assoc[:method_name] %>.to_a(adapter: adapter).each { |r| r.delete!(adapter: adapter) }
<%- else -%>
<%= ind %>      adapter.exec_params(SQL_DELETE_<%= assoc[:method_name].upcase %>, [@<%= assoc[:pk_attr] %>]).close
<%- end -%>
<%- end -%>
<%- has_one.each do |assoc| -%>
<%- if assoc[:target_has_pk] -%>
<%= ind %>      <%= assoc[:method_name] %>(adapter: adapter)&.delete!(adapter: adapter)
<%- else -%>
<%= ind %>      adapter.exec_params(SQL_DELETE_<%= assoc[:method_name].upcase %>, [@<%= assoc[:pk_attr] %>]).close
<%- end -%>
<%- end -%>
<%= ind %>    end
<%= ind %>    result = adapter.exec_params(SQL_DELETE_BY_PK, [@<%= pk_attr %>])
<%= ind %>    raise ::HakumiORM::Error, "DELETE affected 0 rows" if result.affected_rows.zero?
<%= ind %>
<%= ind %>    <%= record_class_name %>::Contract.after_destroy(self, adapter)
<%= ind %>  ensure
<%= ind %>    result&.close
<%= ind %>  end
<%- end -%>
<%- else -%>
<%- if soft_delete -%>
<%= ind %>  sig { params(adapter: ::HakumiORM::Adapter::Base).void }
<%= ind %>  def delete!(adapter: ::HakumiORM.adapter)
<%= ind %>    errors = ::HakumiORM::Errors.new
<%= ind %>    <%= record_class_name %>::Contract.on_destroy(self, errors)
<%= ind %>    raise ::HakumiORM::ValidationError, errors unless errors.valid?
<%= ind %>
<%= ind %>    result = adapter.exec_params(SQL_SOFT_DELETE_BY_PK, [adapter.encode(::HakumiORM::TimeBind.new(::Time.now)), @<%= pk_attr %>])
<%= ind %>    raise ::HakumiORM::Error, "DELETE affected 0 rows" if result.affected_rows.zero?
<%= ind %>
<%= ind %>    <%= record_class_name %>::Contract.after_destroy(self, adapter)
<%= ind %>  ensure
<%= ind %>    result&.close
<%= ind %>  end

<%= ind %>  sig { params(adapter: ::HakumiORM::Adapter::Base).void }
<%= ind %>  def really_delete!(adapter: ::HakumiORM.adapter)
<%= ind %>    errors = ::HakumiORM::Errors.new
<%= ind %>    <%= record_class_name %>::Contract.on_destroy(self, errors)
<%= ind %>    raise ::HakumiORM::ValidationError, errors unless errors.valid?
<%= ind %>
<%= ind %>    result = adapter.exec_params(SQL_DELETE_BY_PK, [@<%= pk_attr %>])
<%= ind %>    raise ::HakumiORM::Error, "DELETE affected 0 rows" if result.affected_rows.zero?
<%= ind %>
<%= ind %>    <%= record_class_name %>::Contract.after_destroy(self, adapter)
<%= ind %>  ensure
<%= ind %>    result&.close
<%= ind %>  end
<%- else -%>
<%= ind %>  sig { params(adapter: ::HakumiORM::Adapter::Base).void }
<%= ind %>  def delete!(adapter: ::HakumiORM.adapter)
<%= ind %>    errors = ::HakumiORM::Errors.new
<%= ind %>    <%= record_class_name %>::Contract.on_destroy(self, errors)
<%= ind %>    raise ::HakumiORM::ValidationError, errors unless errors.valid?
<%= ind %>
<%= ind %>    result = adapter.exec_params(SQL_DELETE_BY_PK, [@<%= pk_attr %>])
<%= ind %>    raise ::HakumiORM::Error, "DELETE affected 0 rows" if result.affected_rows.zero?
<%= ind %>
<%= ind %>    <%= record_class_name %>::Contract.after_destroy(self, adapter)
<%= ind %>  ensure
<%= ind %>    result&.close
<%= ind %>  end
<%- end -%>
<%- end -%>

<%= ind %>  sig { params(adapter: ::HakumiORM::Adapter::Base).returns(<%= record_class_name %>) }
<%= ind %>  def reload!(adapter: ::HakumiORM.adapter)
<%= ind %>    record = self.class.find(@<%= pk_attr %>, adapter: adapter)
<%= ind %>    raise ::HakumiORM::Error, "Record not found on reload" unless record

<%= ind %>    record
<%= ind %>  end

<%- end -%>
<%- if update_sql -%>
<%= ind %>  SQL_UPDATE_BY_PK = T.let('<%= update_sql %>', String)

<%= ind %>  sig { params(<%= update_sig_params %>, adapter: ::HakumiORM::Adapter::Base).returns(<%= record_class_name %>) }
<%= ind %>  def update!(<%= update_defaults %>, adapter: ::HakumiORM.adapter)
<%- proxy_args = update_ins_cols.map { |c| "#{c[:name]}: #{c[:name]}" } -%>
<%- proxy_args << "lock_version: @lock_version" if has_lock_version -%>
<%= ind %>    proxy = <%= record_class_name %>::New.new(<%= proxy_args.join(", ") %>)
<%= ind %>    errors = ::HakumiORM::Errors.new
<%= ind %>    <%= record_class_name %>::Contract.on_all(proxy, errors)
<%= ind %>    <%= record_class_name %>::Contract.on_update(proxy, errors)
<%= ind %>    <%= record_class_name %>::Contract.on_persist(proxy, adapter, errors)
<%= ind %>    raise ::HakumiORM::ValidationError, errors unless errors.valid?

<%- if has_lock_version -%>
<%= ind %>    result = adapter.exec_params(SQL_UPDATE_BY_PK, [<%= update_bind_list %>, @<%= pk_attr %>, adapter.encode(::HakumiORM::IntBind.new(@lock_version))])
<%- if supports_returning -%>
<%= ind %>    record = <%= record_class_name %>.from_result(result, dialect: adapter.dialect).first
<%- else -%>
<%= ind %>    raise ::HakumiORM::StaleObjectError, "Attempted to update a stale #{<%= record_class_name %>.name}" if result.affected_rows.zero?
<%= ind %>    result.close
<%= ind %>    record = <%= record_class_name %>.find(@<%= pk_attr %>, adapter: adapter)
<%- end -%>
<%= ind %>    raise ::HakumiORM::StaleObjectError, "Attempted to update a stale #{<%= record_class_name %>.name}" unless record
<%- else -%>
<%= ind %>    result = adapter.exec_params(SQL_UPDATE_BY_PK, [<%= update_bind_list %>, @<%= pk_attr %>])
<%- if supports_returning -%>
<%= ind %>    record = <%= record_class_name %>.from_result(result, dialect: adapter.dialect).first
<%- else -%>
<%= ind %>    raise ::HakumiORM::Error, "UPDATE returned no rows" if result.affected_rows.zero?
<%= ind %>    result.close
<%= ind %>    record = <%= record_class_name %>.find(@<%= pk_attr %>, adapter: adapter)
<%- end -%>
<%= ind %>    raise ::HakumiORM::Error, "UPDATE returned no rows" unless record
<%- end -%>

<%= ind %>    <%= record_class_name %>::Contract.after_update(record, adapter)
<%= ind %>    record
<%= ind %>  ensure
<%= ind %>    result&.close
<%= ind %>  end

<%- end -%>
<%- if build_sig_params -%>

<%= ind %>  sig { params(<%= build_sig_params %>).returns(<%= record_class_name %>::New) }
<%= ind %>  def self.build(<%= build_args %>)
<%= ind %>    <%= record_class_name %>::New.new(<%= build_forward %>)
<%= ind %>  end

<%= ind %>  sig { params(records: T::Array[<%= record_class_name %>::New], adapter: ::HakumiORM::Adapter::Base).returns(T::Array[<%= record_class_name %>]) }
<%= ind %>  def self.insert_all(records, adapter: ::HakumiORM.adapter)
<%= ind %>    return [] if records.empty?
<%= ind %>
<%= ind %>    dialect = adapter.dialect
<%= ind %>    buf = ::String.new(capacity: 256)
<%= ind %>    binds = T.let([], T::Array[::HakumiORM::PGValue])
<%= ind %>    idx = 0
<%= ind %>
<%= ind %>    buf << '<%= insert_all_prefix %>'
<%= ind %>    records.each_with_index do |rec, ri|
<%= ind %>      buf << ", " if ri > 0
<%= ind %>      buf << "("
<%- insert_all_columns.each_with_index do |col, ci| -%>
<%= ind %>      buf << ", " if <%= ci %> > 0
<%= ind %>      buf << dialect.bind_marker(idx)
<%= ind %>      binds << <%= col[:bind_expr] %>
<%= ind %>      idx += 1
<%- end -%>
<%= ind %>      buf << ")"
<%= ind %>    end
<%- if supports_returning -%>
<%= ind %>    buf << ' RETURNING <%= returning_cols %>'
<%- end -%>
<%= ind %>
<%= ind %>    result = adapter.exec_params(buf, binds)
<%- if supports_returning -%>
<%= ind %>    from_result(result, dialect: dialect)
<%- else -%>
<%= ind %>    result.close
<%= ind %>    first_id = adapter.last_insert_id
<%= ind %>    count = records.length
<%= ind %>    fetch = adapter.exec("SELECT <%= returning_cols %> FROM <%= insert_all_table %> WHERE <%= insert_all_pk %> >= #{first_id} AND <%= insert_all_pk %> < #{first_id + count} ORDER BY <%= insert_all_pk %>")
<%= ind %>    from_result(fetch, dialect: dialect)
<%- end -%>
<%= ind %>  ensure
<%= ind %>    result&.close
<%= ind %>  end
<%- end -%>
<%- has_many.each do |assoc| -%>

<%= ind %>  sig { returns(<%= assoc[:relation_class] %>) }
<%= ind %>  def <%= assoc[:method_name] %>
<%= ind %>    cached = @_preloaded_<%= assoc[:method_name] %>
<%= ind %>    if cached
<%= ind %>      return <%= assoc[:relation_class] %>.new._set_preloaded(cached)
<%= ind %>    end
<%= ind %>    <%= assoc[:relation_class] %>.new.where(<%= assoc[:schema_module] %>::<%= assoc[:fk_const] %>.eq(@<%= assoc[:pk_attr] %>))<%= assoc[:scope_expr] ? ".where(#{assoc[:scope_expr]})" : "" %>
<%= ind %>  end

<%= ind %>  sig { params(records: T::Array[<%= record_class_name %>], adapter: ::HakumiORM::Adapter::Base).void }
<%= ind %>  def self.preload_<%= assoc[:method_name] %>(records, adapter: ::HakumiORM.adapter)
<%= ind %>    return if records.empty?

<%= ind %>    ids = records.map { |r| r.<%= assoc[:pk_attr] %> }.uniq
<%= ind %>    return if ids.empty?

<%= ind %>    all_related = <%= assoc[:relation_class] %>.new.where(<%= assoc[:schema_module] %>::<%= assoc[:fk_const] %>.in_list(ids))<%= assoc[:scope_expr] ? ".where(#{assoc[:scope_expr]})" : "" %>.to_a(adapter: adapter)
<%= ind %>    grouped = T.let({}, T::Hash[<%= assoc[:pk_ruby_type] %>, T::Array[<%= assoc[:record_class] %>]])
<%= ind %>    all_related.each do |related|
<%= ind %>      key = related.<%= assoc[:fk_attr] %>
<%= ind %>      (grouped[key] ||= []) << related
<%= ind %>    end

<%- if assoc[:inverse_method] -%>
<%= ind %>    indexed_parents = T.let({}, T::Hash[<%= assoc[:pk_ruby_type] %>, <%= record_class_name %>])
<%= ind %>    records.each { |r| indexed_parents[r.<%= assoc[:pk_attr] %>] = r }

<%= ind %>    all_related.each do |child|
<%= ind %>      parent = indexed_parents[child.<%= assoc[:fk_attr] %>]
<%= ind %>      child._preloaded_<%= assoc[:inverse_method] %> = [parent] if parent
<%= ind %>    end

<%- end -%>
<%= ind %>    records.each do |record|
<%= ind %>      record._preloaded_<%= assoc[:method_name] %> = grouped[record.<%= assoc[:pk_attr] %>] || []
<%= ind %>    end
<%= ind %>  end
<%- end -%>
<%- has_one.each do |assoc| -%>

<%= ind %>  sig { params(adapter: ::HakumiORM::Adapter::Base).returns(T.nilable(<%= assoc[:record_class] %>)) }
<%= ind %>  def <%= assoc[:method_name] %>(adapter: ::HakumiORM.adapter)
<%= ind %>    cached = @_preloaded_<%= assoc[:method_name] %>
<%= ind %>    return cached.first if cached

<%- scope_chain = assoc[:scope_expr] ? ".where(#{assoc[:scope_expr]})" : "" -%>
<%- if assoc[:order_by_const] -%>
<%= ind %>    <%= assoc[:relation_class] %>.new.where(<%= assoc[:schema_module] %>::<%= assoc[:fk_const] %>.eq(@<%= assoc[:pk_attr] %>))<%= scope_chain %>.order(<%= assoc[:schema_module] %>::<%= assoc[:order_by_const] %>.desc).first(adapter: adapter)
<%- else -%>
<%= ind %>    <%= assoc[:relation_class] %>.new.where(<%= assoc[:schema_module] %>::<%= assoc[:fk_const] %>.eq(@<%= assoc[:pk_attr] %>))<%= scope_chain %>.first(adapter: adapter)
<%- end -%>
<%= ind %>  end

<%= ind %>  sig { params(records: T::Array[<%= record_class_name %>], adapter: ::HakumiORM::Adapter::Base).void }
<%= ind %>  def self.preload_<%= assoc[:method_name] %>(records, adapter: ::HakumiORM.adapter)
<%= ind %>    return if records.empty?

<%= ind %>    ids = records.map { |r| r.<%= assoc[:pk_attr] %> }.uniq
<%= ind %>    return if ids.empty?

<%- if assoc[:order_by_const] -%>
<%= ind %>    all_related = <%= assoc[:relation_class] %>.new.where(<%= assoc[:schema_module] %>::<%= assoc[:fk_const] %>.in_list(ids))<%= scope_chain %>.order(<%= assoc[:schema_module] %>::<%= assoc[:order_by_const] %>.desc).to_a(adapter: adapter)
<%- else -%>
<%= ind %>    all_related = <%= assoc[:relation_class] %>.new.where(<%= assoc[:schema_module] %>::<%= assoc[:fk_const] %>.in_list(ids))<%= scope_chain %>.to_a(adapter: adapter)
<%- end -%>
<%= ind %>    indexed = T.let({}, T::Hash[<%= assoc[:pk_ruby_type] %>, <%= assoc[:record_class] %>])
<%= ind %>    all_related.each { |r| indexed[r.<%= assoc[:fk_attr] %>] = r }

<%- if assoc[:inverse_method] -%>
<%= ind %>    indexed_parents = T.let({}, T::Hash[<%= assoc[:pk_ruby_type] %>, <%= record_class_name %>])
<%= ind %>    records.each { |r| indexed_parents[r.<%= assoc[:pk_attr] %>] = r }

<%= ind %>    all_related.each do |child|
<%= ind %>      parent = indexed_parents[child.<%= assoc[:fk_attr] %>]
<%= ind %>      child._preloaded_<%= assoc[:inverse_method] %> = [parent] if parent
<%= ind %>    end

<%- end -%>
<%= ind %>    records.each do |record|
<%= ind %>      related = indexed[record.<%= assoc[:pk_attr] %>]
<%= ind %>      record._preloaded_<%= assoc[:method_name] %> = related ? [related] : []
<%= ind %>    end
<%= ind %>  end
<%- end -%>
<%- has_many_through.each do |assoc| -%>
<%- if assoc[:singular] == "true" -%>

<%= ind %>  sig { params(adapter: ::HakumiORM::Adapter::Base).returns(T.nilable(<%= assoc[:target_record] %>)) }
<%= ind %>  def <%= assoc[:method_name] %>(adapter: ::HakumiORM.adapter)
<%= ind %>    sub = <%= assoc[:join_relation] %>.new
<%= ind %>      .where(<%= assoc[:join_schema] %>::<%= assoc[:join_fk_const] %>.eq(@<%= assoc[:pk_attr] %>))
<%= ind %>      .select(<%= assoc[:join_schema] %>::<%= assoc[:join_select_const] %>)
<%= ind %>      .compile(adapter.dialect)
<%= ind %>    <%= assoc[:target_relation] %>.new.where(
<%= ind %>      ::HakumiORM::SubqueryExpr.new(<%= assoc[:target_schema] %>::<%= assoc[:target_match_const] %>, :in, sub)
<%= ind %>    ).first(adapter: adapter)
<%= ind %>  end
<%- else -%>

<%= ind %>  sig { params(adapter: ::HakumiORM::Adapter::Base).returns(<%= assoc[:target_relation] %>) }
<%= ind %>  def <%= assoc[:method_name] %>(adapter: ::HakumiORM.adapter)
<%= ind %>    sub = <%= assoc[:join_relation] %>.new
<%= ind %>      .where(<%= assoc[:join_schema] %>::<%= assoc[:join_fk_const] %>.eq(@<%= assoc[:pk_attr] %>))
<%= ind %>      .select(<%= assoc[:join_schema] %>::<%= assoc[:join_select_const] %>)
<%= ind %>      .compile(adapter.dialect)
<%= ind %>    <%= assoc[:target_relation] %>.new.where(
<%= ind %>      ::HakumiORM::SubqueryExpr.new(<%= assoc[:target_schema] %>::<%= assoc[:target_match_const] %>, :in, sub)
<%= ind %>    )
<%= ind %>  end
<%- end -%>
<%- end -%>
<%- belongs_to.each do |assoc| -%>

<%- if assoc[:nullable] -%>
<%= ind %>  sig { params(adapter: ::HakumiORM::Adapter::Base).returns(T.nilable(<%= assoc[:record_class] %>)) }
<%= ind %>  def <%= assoc[:method_name] %>(adapter: ::HakumiORM.adapter)
<%= ind %>    cached = @_preloaded_<%= assoc[:method_name] %>
<%= ind %>    return cached.first if cached

<%= ind %>    fk_val = @<%= assoc[:fk_attr] %>
<%= ind %>    return nil if fk_val.nil?

<%= ind %>    <%= assoc[:record_class] %>.find(fk_val, adapter: adapter)
<%= ind %>  end
<%- else -%>
<%= ind %>  sig { params(adapter: ::HakumiORM::Adapter::Base).returns(T.nilable(<%= assoc[:record_class] %>)) }
<%= ind %>  def <%= assoc[:method_name] %>(adapter: ::HakumiORM.adapter)
<%= ind %>    cached = @_preloaded_<%= assoc[:method_name] %>
<%= ind %>    return cached.first if cached

<%= ind %>    <%= assoc[:record_class] %>.find(@<%= assoc[:fk_attr] %>, adapter: adapter)
<%= ind %>  end
<%- end -%>

<%= ind %>  sig { params(records: T::Array[<%= record_class_name %>], adapter: ::HakumiORM::Adapter::Base).void }
<%= ind %>  def self.preload_<%= assoc[:method_name] %>(records, adapter: ::HakumiORM.adapter)
<%= ind %>    return if records.empty?

<%- if assoc[:nullable] -%>
<%= ind %>    fk_values = records.map { |r| r.<%= assoc[:fk_attr] %> }.compact.uniq
<%- else -%>
<%= ind %>    fk_values = records.map { |r| r.<%= assoc[:fk_attr] %> }.uniq
<%- end -%>
<%= ind %>    return if fk_values.empty?

<%= ind %>    all_related = <%= assoc[:target_relation] %>.new.where(<%= assoc[:target_schema] %>::<%= assoc[:target_pk_const] %>.in_list(fk_values)).to_a(adapter: adapter)
<%= ind %>    indexed = T.let({}, T::Hash[<%= assoc[:target_pk_type] %>, <%= assoc[:record_class] %>])
<%= ind %>    all_related.each { |r| indexed[r.<%= assoc[:target_pk_attr] %>] = r }

<%= ind %>    records.each do |record|
<%- if assoc[:nullable] -%>
<%= ind %>      fk = record.<%= assoc[:fk_attr] %>
<%= ind %>      record._preloaded_<%= assoc[:method_name] %> = fk ? [indexed[fk]].compact : []
<%- else -%>
<%= ind %>      record._preloaded_<%= assoc[:method_name] %> = [indexed[record.<%= assoc[:fk_attr] %>]].compact
<%- end -%>
<%= ind %>    end
<%= ind %>  end
<%- end -%>
<%= ind %>end
<%- if module_name -%>
end
<%- end -%>
