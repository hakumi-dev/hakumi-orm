# typed: strict
# frozen_string_literal: true
# GENERATED BY hakumi-orm -- DO NOT EDIT

require "bigdecimal"

<%- if module_name -%>
module <%= module_name %>
<%- end -%>
<%= ind %>class <%= record_class_name %>
<%= ind %>  extend T::Sig

<%- columns.each do |col| -%>
<%= ind %>  sig { returns(<%= col[:ruby_type] %>) }
<%= ind %>  attr_reader :<%= col[:name] %>

<%- end -%>
<%- has_many.each do |assoc| -%>
<%= ind %>  sig { returns(T.nilable(T::Array[<%= assoc[:record_class] %>])) }
<%= ind %>  attr_accessor :_preloaded_<%= assoc[:method_name] %>

<%- end -%>
<%- belongs_to.each do |assoc| -%>
<%= ind %>  sig { returns(T.nilable(T::Array[<%= assoc[:record_class] %>])) }
<%= ind %>  attr_accessor :_preloaded_<%= assoc[:method_name] %>

<%- end -%>
<%= ind %>  sig { params(<%= init_sig_params %>).void }
<%= ind %>  def initialize(<%= init_args %>)
<%- columns.each do |col| -%>
<%= ind %>    @<%= col[:name] %> = T.let(<%= col[:name] %>, <%= col[:ruby_type] %>)
<%- end -%>
<%- has_many.each do |assoc| -%>
<%= ind %>    @_preloaded_<%= assoc[:method_name] %> = T.let(nil, T.nilable(T::Array[<%= assoc[:record_class] %>]))
<%- end -%>
<%- belongs_to.each do |assoc| -%>
<%= ind %>    @_preloaded_<%= assoc[:method_name] %> = T.let(nil, T.nilable(T::Array[<%= assoc[:record_class] %>]))
<%- end -%>
<%= ind %>  end

<%= ind %>  sig { params(result: ::HakumiORM::Adapter::Result).returns(T::Array[<%= record_class_name %>]) }
<%= ind %>  def self.from_result(result)
<%= ind %>    n = result.row_count
<%= ind %>    return [] if n.zero?
<%= ind %>
<%- columns.each_with_index do |_col, ci| -%>
<%= ind %>    c<%= ci %> = result.column_values(<%= ci %>)
<%- end -%>
<%= ind %>    rows = ::Array.new(n)
<%= ind %>    i = 0
<%= ind %>    while i < n
<%= ind %>      obj = allocate
<%- columns.each_with_index do |col, ci| -%>
<%= ind %>      obj.instance_variable_set(:@<%= col[:name] %>, <%= cast_lines[ci] %>)
<%- end -%>
<%= ind %>      rows[i] = obj
<%= ind %>      i += 1
<%= ind %>    end
<%= ind %>    rows
<%= ind %>  end

<%- if find_sql -%>
<%= ind %>  SQL_FIND_BY_PK = T.let('<%= find_sql %>', String)
<%= ind %>  STMT_FIND_BY_PK = T.let('<%= stmt_find_name %>', String)

<%= ind %>  sig { params(pk_value: <%= pk_ruby_type %>, adapter: ::HakumiORM::Adapter::Base).returns(T.nilable(<%= record_class_name %>)) }
<%= ind %>  def self.find(pk_value, adapter: ::HakumiORM.adapter)
<%= ind %>    adapter.prepare(STMT_FIND_BY_PK, SQL_FIND_BY_PK)
<%= ind %>    result = adapter.exec_prepared(STMT_FIND_BY_PK, [pk_value])
<%= ind %>    return nil if result.row_count.zero?

<%= ind %>    from_result(result).first
<%= ind %>  ensure
<%= ind %>    result&.close
<%= ind %>  end

<%- end -%>
<%= ind %>  sig { params(expr: ::HakumiORM::Expr).returns(<%= qualified_relation %>) }
<%= ind %>  def self.where(expr)
<%= ind %>    <%= qualified_relation %>.new.where(expr)
<%= ind %>  end

<%= ind %>  sig { returns(<%= qualified_relation %>) }
<%= ind %>  def self.all
<%= ind %>    <%= qualified_relation %>.new
<%= ind %>  end
<%- if build_sig_params -%>

<%= ind %>  sig { params(<%= build_sig_params %>).returns(<%= record_class_name %>::New) }
<%= ind %>  def self.build(<%= build_args %>)
<%= ind %>    <%= record_class_name %>::New.new(<%= build_forward %>)
<%= ind %>  end

<%= ind %>  sig { params(records: T::Array[<%= record_class_name %>::New], adapter: ::HakumiORM::Adapter::Base).returns(T::Array[<%= record_class_name %>]) }
<%= ind %>  def self.insert_all(records, adapter: ::HakumiORM.adapter)
<%= ind %>    return [] if records.empty?
<%= ind %>
<%= ind %>    dialect = adapter.dialect
<%= ind %>    buf = ::String.new(capacity: 256)
<%= ind %>    binds = T.let([], T::Array[::HakumiORM::PGValue])
<%= ind %>    idx = 0
<%= ind %>
<%= ind %>    buf << '<%= insert_all_prefix %>'
<%= ind %>    records.each_with_index do |rec, ri|
<%= ind %>      buf << ", " if ri > 0
<%= ind %>      buf << "("
<%- insert_all_columns.each_with_index do |col, ci| -%>
<%= ind %>      buf << ", " if <%= ci %> > 0
<%= ind %>      buf << dialect.bind_marker(idx)
<%= ind %>      binds << rec.<%= col[:name] %>
<%= ind %>      idx += 1
<%- end -%>
<%= ind %>      buf << ")"
<%= ind %>    end
<%- if supports_returning -%>
<%= ind %>    buf << ' RETURNING <%= returning_cols %>'
<%- end -%>
<%= ind %>
<%= ind %>    result = adapter.exec_params(buf, binds)
<%= ind %>    from_result(result)
<%= ind %>  ensure
<%= ind %>    result&.close
<%= ind %>  end
<%- end -%>
<%- has_many.each do |assoc| -%>

<%= ind %>  sig { returns(<%= assoc[:relation_class] %>) }
<%= ind %>  def <%= assoc[:method_name] %>
<%= ind %>    cached = @_preloaded_<%= assoc[:method_name] %>
<%= ind %>    if cached
<%= ind %>      return <%= assoc[:relation_class] %>.new._set_preloaded(cached)
<%= ind %>    end
<%= ind %>    <%= assoc[:relation_class] %>.new.where(<%= assoc[:schema_module] %>::<%= assoc[:fk_const] %>.eq(@<%= assoc[:pk_attr] %>))
<%= ind %>  end

<%= ind %>  sig { params(records: T::Array[<%= record_class_name %>], adapter: ::HakumiORM::Adapter::Base).void }
<%= ind %>  def self.preload_<%= assoc[:method_name] %>(records, adapter: ::HakumiORM.adapter)
<%= ind %>    return if records.empty?

<%= ind %>    ids = records.map { |r| r.<%= assoc[:pk_attr] %> }.uniq
<%= ind %>    return if ids.empty?

<%= ind %>    all_related = <%= assoc[:relation_class] %>.new.where(<%= assoc[:schema_module] %>::<%= assoc[:fk_const] %>.in_list(ids)).to_a(adapter: adapter)
<%= ind %>    grouped = T.let({}, T::Hash[<%= assoc[:pk_ruby_type] %>, T::Array[<%= assoc[:record_class] %>]])
<%= ind %>    all_related.each do |related|
<%= ind %>      key = related.<%= assoc[:fk_attr] %>
<%= ind %>      (grouped[key] ||= []) << related
<%= ind %>    end

<%= ind %>    records.each do |record|
<%= ind %>      record._preloaded_<%= assoc[:method_name] %> = grouped[record.<%= assoc[:pk_attr] %>] || []
<%= ind %>    end
<%= ind %>  end
<%- end -%>
<%- belongs_to.each do |assoc| -%>

<%- if assoc[:nullable] -%>
<%= ind %>  sig { params(adapter: ::HakumiORM::Adapter::Base).returns(T.nilable(<%= assoc[:record_class] %>)) }
<%= ind %>  def <%= assoc[:method_name] %>(adapter: ::HakumiORM.adapter)
<%= ind %>    cached = @_preloaded_<%= assoc[:method_name] %>
<%= ind %>    return cached.first if cached

<%= ind %>    fk_val = @<%= assoc[:fk_attr] %>
<%= ind %>    return nil if fk_val.nil?

<%= ind %>    <%= assoc[:record_class] %>.find(fk_val, adapter: adapter)
<%= ind %>  end
<%- else -%>
<%= ind %>  sig { params(adapter: ::HakumiORM::Adapter::Base).returns(T.nilable(<%= assoc[:record_class] %>)) }
<%= ind %>  def <%= assoc[:method_name] %>(adapter: ::HakumiORM.adapter)
<%= ind %>    cached = @_preloaded_<%= assoc[:method_name] %>
<%= ind %>    return cached.first if cached

<%= ind %>    <%= assoc[:record_class] %>.find(@<%= assoc[:fk_attr] %>, adapter: adapter)
<%= ind %>  end
<%- end -%>

<%= ind %>  sig { params(records: T::Array[<%= record_class_name %>], adapter: ::HakumiORM::Adapter::Base).void }
<%= ind %>  def self.preload_<%= assoc[:method_name] %>(records, adapter: ::HakumiORM.adapter)
<%= ind %>    return if records.empty?

<%= ind %>    fk_values = records.map { |r| r.<%= assoc[:fk_attr] %> }.compact.uniq
<%= ind %>    return if fk_values.empty?

<%= ind %>    all_related = <%= assoc[:target_relation] %>.new.where(<%= assoc[:target_schema] %>::<%= assoc[:target_pk_const] %>.in_list(fk_values)).to_a(adapter: adapter)
<%= ind %>    indexed = T.let({}, T::Hash[<%= assoc[:target_pk_type] %>, <%= assoc[:record_class] %>])
<%= ind %>    all_related.each { |r| indexed[r.<%= assoc[:target_pk_attr] %>] = r }

<%= ind %>    records.each do |record|
<%= ind %>      fk = record.<%= assoc[:fk_attr] %>
<%= ind %>      record._preloaded_<%= assoc[:method_name] %> = fk ? [indexed[fk]].compact : []
<%= ind %>    end
<%= ind %>  end
<%- end -%>
<%= ind %>end
<%- if module_name -%>
end
<%- end -%>
