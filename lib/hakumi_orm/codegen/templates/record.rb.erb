# typed: strict
# frozen_string_literal: true
# GENERATED BY hakumi-orm -- DO NOT EDIT

require "bigdecimal"

<%- if module_name -%>
module <%= module_name %>
<%- end -%>
<%= ind %>class <%= record_class_name %>
<%= ind %>  extend T::Sig

<%- columns.each do |col| -%>
<%= ind %>  sig { returns(<%= col[:ruby_type] %>) }
<%= ind %>  attr_reader :<%= col[:name] %>

<%- end -%>
<%- has_many.each do |assoc| -%>
<%= ind %>  sig { returns(T.nilable(T::Array[<%= assoc[:record_class] %>])) }
<%= ind %>  attr_accessor :_preloaded_<%= assoc[:method_name] %>

<%- end -%>
<%- has_one.each do |assoc| -%>
<%= ind %>  sig { returns(T.nilable(T::Array[<%= assoc[:record_class] %>])) }
<%= ind %>  attr_accessor :_preloaded_<%= assoc[:method_name] %>

<%- end -%>
<%- belongs_to.each do |assoc| -%>
<%= ind %>  sig { returns(T.nilable(T::Array[<%= assoc[:record_class] %>])) }
<%= ind %>  attr_accessor :_preloaded_<%= assoc[:method_name] %>

<%- end -%>
<%= ind %>  sig { params(<%= init_sig_params %>).void }
<%= ind %>  def initialize(<%= init_args %>)
<%- columns.each do |col| -%>
<%= ind %>    @<%= col[:name] %> = T.let(<%= col[:name] %>, <%= col[:ruby_type] %>)
<%- end -%>
<%- has_many.each do |assoc| -%>
<%= ind %>    @_preloaded_<%= assoc[:method_name] %> = T.let(nil, T.nilable(T::Array[<%= assoc[:record_class] %>]))
<%- end -%>
<%- has_one.each do |assoc| -%>
<%= ind %>    @_preloaded_<%= assoc[:method_name] %> = T.let(nil, T.nilable(T::Array[<%= assoc[:record_class] %>]))
<%- end -%>
<%- belongs_to.each do |assoc| -%>
<%= ind %>    @_preloaded_<%= assoc[:method_name] %> = T.let(nil, T.nilable(T::Array[<%= assoc[:record_class] %>]))
<%- end -%>
<%= ind %>  end

<%= ind %>  sig { params(result: ::HakumiORM::Adapter::Result).returns(T::Array[<%= record_class_name %>]) }
<%= ind %>  def self.from_result(result)
<%= ind %>    n = result.row_count
<%= ind %>    return [] if n.zero?
<%= ind %>
<%- columns.each_with_index do |_col, ci| -%>
<%= ind %>    c<%= ci %> = result.column_values(<%= ci %>)
<%- end -%>
<%= ind %>    rows = ::Array.new(n)
<%= ind %>    i = 0
<%= ind %>    while i < n
<%= ind %>      obj = allocate
<%- columns.each_with_index do |col, ci| -%>
<%= ind %>      obj.instance_variable_set(:@<%= col[:name] %>, <%= cast_lines[ci] %>)
<%- end -%>
<%= ind %>      rows[i] = obj
<%= ind %>      i += 1
<%= ind %>    end
<%= ind %>    rows
<%= ind %>  end

<%- if find_sql -%>
<%= ind %>  SQL_FIND_BY_PK = T.let('<%= find_sql %>', String)
<%= ind %>  STMT_FIND_BY_PK = T.let('<%= stmt_find_name %>', String)

<%= ind %>  sig { params(pk_value: <%= pk_ruby_type %>, adapter: ::HakumiORM::Adapter::Base).returns(T.nilable(<%= record_class_name %>)) }
<%= ind %>  def self.find(pk_value, adapter: ::HakumiORM.adapter)
<%= ind %>    adapter.prepare(STMT_FIND_BY_PK, SQL_FIND_BY_PK)
<%= ind %>    result = adapter.exec_prepared(STMT_FIND_BY_PK, [pk_value])
<%= ind %>    return nil if result.row_count.zero?

<%= ind %>    from_result(result).first
<%= ind %>  ensure
<%= ind %>    result&.close
<%= ind %>  end

<%- end -%>
<%= ind %>  sig { params(expr: ::HakumiORM::Expr).returns(<%= qualified_relation %>) }
<%= ind %>  def self.where(expr)
<%= ind %>    <%= qualified_relation %>.new.where(expr)
<%= ind %>  end

<%= ind %>  sig { params(expr: ::HakumiORM::Expr, adapter: ::HakumiORM::Adapter::Base).returns(T.nilable(<%= record_class_name %>)) }
<%= ind %>  def self.find_by(expr, adapter: ::HakumiORM.adapter)
<%= ind %>    <%= qualified_relation %>.new.where(expr).first(adapter: adapter)
<%= ind %>  end

<%= ind %>  sig { params(expr: ::HakumiORM::Expr, adapter: ::HakumiORM::Adapter::Base).returns(T::Boolean) }
<%= ind %>  def self.exists?(expr, adapter: ::HakumiORM.adapter)
<%= ind %>    <%= qualified_relation %>.new.where(expr).exists?(adapter: adapter)
<%= ind %>  end

<%= ind %>  sig { returns(<%= qualified_relation %>) }
<%= ind %>  def self.all
<%= ind %>    <%= qualified_relation %>.new
<%= ind %>  end

<%= ind %>  sig { returns(T::Hash[Symbol, <%= to_h_value_type %>]) }
<%= ind %>  def to_h
<%= ind %>    {
<%- columns.each_with_index do |col, i| -%>
<%= ind %>      <%= col[:name] %>: @<%= col[:name] %><%= i < columns.length - 1 ? "," : "" %>
<%- end -%>
<%= ind %>    }
<%= ind %>  end

<%= ind %>  sig { params(only: T.nilable(T::Array[Symbol]), except: T.nilable(T::Array[Symbol])).returns(T::Hash[String, <%= as_json_value_type %>]) }
<%= ind %>  def as_json(only: nil, except: nil)
<%= ind %>    h = T.let({}, T::Hash[String, <%= as_json_value_type %>])
<%- columns.each do |col| -%>
<%= ind %>    h["<%= col[:name] %>"] = <%= col[:json_expr] %> unless (only && !only.include?(:<%= col[:name] %>)) || (except&.include?(:<%= col[:name] %>))
<%- end -%>
<%= ind %>    h
<%= ind %>  end
<%- if delete_sql -%>
<%= ind %>  SQL_DELETE_BY_PK = T.let('<%= delete_sql %>', String)
<%- (has_many + has_one).each do |assoc| -%>
<%= ind %>  SQL_DELETE_<%= assoc[:method_name].upcase %> = T.let('<%= assoc[:delete_sql] %>', String)
<%- end -%>

<%- if has_many.any? || has_one.any? -%>
<%= ind %>  sig { params(dependent: Symbol, adapter: ::HakumiORM::Adapter::Base).void }
<%= ind %>  def delete!(dependent: :none, adapter: ::HakumiORM.adapter)
<%= ind %>    case dependent
<%= ind %>    when :delete_all
<%- (has_many + has_one).each do |assoc| -%>
<%= ind %>      adapter.exec_params(SQL_DELETE_<%= assoc[:method_name].upcase %>, [@<%= pk_attr %>]).close
<%- end -%>
<%= ind %>    when :destroy
<%- has_many.each do |assoc| -%>
<%= ind %>      <%= assoc[:method_name] %>.to_a(adapter: adapter).each { |r| r.delete!(adapter: adapter) }
<%- end -%>
<%- has_one.each do |assoc| -%>
<%= ind %>      <%= assoc[:method_name] %>(adapter: adapter)&.delete!(adapter: adapter)
<%- end -%>
<%= ind %>    end
<%= ind %>    result = adapter.exec_params(SQL_DELETE_BY_PK, [@<%= pk_attr %>])
<%= ind %>    raise ::HakumiORM::Error, "DELETE affected 0 rows" if result.affected_rows.zero?
<%= ind %>  ensure
<%= ind %>    result&.close
<%= ind %>  end
<%- else -%>
<%= ind %>  sig { params(adapter: ::HakumiORM::Adapter::Base).void }
<%= ind %>  def delete!(adapter: ::HakumiORM.adapter)
<%= ind %>    result = adapter.exec_params(SQL_DELETE_BY_PK, [@<%= pk_attr %>])
<%= ind %>    raise ::HakumiORM::Error, "DELETE affected 0 rows" if result.affected_rows.zero?
<%= ind %>  ensure
<%= ind %>    result&.close
<%= ind %>  end
<%- end -%>

<%= ind %>  sig { params(adapter: ::HakumiORM::Adapter::Base).returns(<%= record_class_name %>) }
<%= ind %>  def reload!(adapter: ::HakumiORM.adapter)
<%= ind %>    record = self.class.find(@<%= pk_attr %>, adapter: adapter)
<%= ind %>    raise ::HakumiORM::Error, "Record not found on reload" unless record

<%= ind %>    record
<%= ind %>  end

<%- end -%>
<%- if update_sql -%>
<%= ind %>  SQL_UPDATE_BY_PK = T.let('<%= update_sql %>', String)

<%= ind %>  sig { params(<%= update_sig_params %>, adapter: ::HakumiORM::Adapter::Base).returns(<%= record_class_name %>) }
<%= ind %>  def update!(<%= update_defaults %>, adapter: ::HakumiORM.adapter)
<%= ind %>    proxy = <%= record_class_name %>::New.new(<%= update_ins_cols.map { |c| "#{c[:name]}: #{c[:name]}" }.join(", ") %>)
<%= ind %>    errors = ::HakumiORM::Errors.new
<%= ind %>    <%= record_class_name %>::Contract.on_all(proxy, errors)
<%= ind %>    <%= record_class_name %>::Contract.on_update(proxy, errors)
<%= ind %>    <%= record_class_name %>::Contract.on_persist(proxy, adapter, errors)
<%= ind %>    raise ::HakumiORM::ValidationError, errors unless errors.valid?

<%- if has_lock_version -%>
<%= ind %>    result = adapter.exec_params(SQL_UPDATE_BY_PK, [<%= update_bind_list %>, @<%= pk_attr %>, ::HakumiORM::IntBind.new(@lock_version).pg_value])
<%= ind %>    record = <%= record_class_name %>.from_result(result).first
<%= ind %>    raise ::HakumiORM::StaleObjectError, "Attempted to update a stale #{<%= record_class_name %>.name}" unless record
<%- else -%>
<%= ind %>    result = adapter.exec_params(SQL_UPDATE_BY_PK, [<%= update_bind_list %>, @<%= pk_attr %>])
<%= ind %>    record = <%= record_class_name %>.from_result(result).first
<%= ind %>    raise ::HakumiORM::Error, "UPDATE returned no rows" unless record
<%- end -%>

<%= ind %>    record
<%= ind %>  ensure
<%= ind %>    result&.close
<%= ind %>  end

<%- end -%>
<%- if build_sig_params -%>

<%= ind %>  sig { params(<%= build_sig_params %>).returns(<%= record_class_name %>::New) }
<%= ind %>  def self.build(<%= build_args %>)
<%= ind %>    <%= record_class_name %>::New.new(<%= build_forward %>)
<%= ind %>  end

<%= ind %>  sig { params(records: T::Array[<%= record_class_name %>::New], adapter: ::HakumiORM::Adapter::Base).returns(T::Array[<%= record_class_name %>]) }
<%= ind %>  def self.insert_all(records, adapter: ::HakumiORM.adapter)
<%= ind %>    return [] if records.empty?
<%= ind %>
<%= ind %>    dialect = adapter.dialect
<%= ind %>    buf = ::String.new(capacity: 256)
<%= ind %>    binds = T.let([], T::Array[::HakumiORM::PGValue])
<%= ind %>    idx = 0
<%= ind %>
<%= ind %>    buf << '<%= insert_all_prefix %>'
<%= ind %>    records.each_with_index do |rec, ri|
<%= ind %>      buf << ", " if ri > 0
<%= ind %>      buf << "("
<%- insert_all_columns.each_with_index do |col, ci| -%>
<%= ind %>      buf << ", " if <%= ci %> > 0
<%= ind %>      buf << dialect.bind_marker(idx)
<%= ind %>      binds << rec.<%= col[:name] %>
<%= ind %>      idx += 1
<%- end -%>
<%= ind %>      buf << ")"
<%= ind %>    end
<%- if supports_returning -%>
<%= ind %>    buf << ' RETURNING <%= returning_cols %>'
<%- end -%>
<%= ind %>
<%= ind %>    result = adapter.exec_params(buf, binds)
<%= ind %>    from_result(result)
<%= ind %>  ensure
<%= ind %>    result&.close
<%= ind %>  end
<%- end -%>
<%- has_many.each do |assoc| -%>

<%= ind %>  sig { returns(<%= assoc[:relation_class] %>) }
<%= ind %>  def <%= assoc[:method_name] %>
<%= ind %>    cached = @_preloaded_<%= assoc[:method_name] %>
<%= ind %>    if cached
<%= ind %>      return <%= assoc[:relation_class] %>.new._set_preloaded(cached)
<%= ind %>    end
<%= ind %>    <%= assoc[:relation_class] %>.new.where(<%= assoc[:schema_module] %>::<%= assoc[:fk_const] %>.eq(@<%= assoc[:pk_attr] %>))
<%= ind %>  end

<%= ind %>  sig { params(records: T::Array[<%= record_class_name %>], adapter: ::HakumiORM::Adapter::Base).void }
<%= ind %>  def self.preload_<%= assoc[:method_name] %>(records, adapter: ::HakumiORM.adapter)
<%= ind %>    return if records.empty?

<%= ind %>    ids = records.map { |r| r.<%= assoc[:pk_attr] %> }.uniq
<%= ind %>    return if ids.empty?

<%= ind %>    all_related = <%= assoc[:relation_class] %>.new.where(<%= assoc[:schema_module] %>::<%= assoc[:fk_const] %>.in_list(ids)).to_a(adapter: adapter)
<%= ind %>    grouped = T.let({}, T::Hash[<%= assoc[:pk_ruby_type] %>, T::Array[<%= assoc[:record_class] %>]])
<%= ind %>    all_related.each do |related|
<%= ind %>      key = related.<%= assoc[:fk_attr] %>
<%= ind %>      (grouped[key] ||= []) << related
<%= ind %>    end

<%= ind %>    records.each do |record|
<%= ind %>      record._preloaded_<%= assoc[:method_name] %> = grouped[record.<%= assoc[:pk_attr] %>] || []
<%= ind %>    end
<%= ind %>  end
<%- end -%>
<%- has_one.each do |assoc| -%>

<%= ind %>  sig { params(adapter: ::HakumiORM::Adapter::Base).returns(T.nilable(<%= assoc[:record_class] %>)) }
<%= ind %>  def <%= assoc[:method_name] %>(adapter: ::HakumiORM.adapter)
<%= ind %>    cached = @_preloaded_<%= assoc[:method_name] %>
<%= ind %>    return cached&.first if cached

<%= ind %>    <%= assoc[:relation_class] %>.new.where(<%= assoc[:schema_module] %>::<%= assoc[:fk_const] %>.eq(@<%= assoc[:pk_attr] %>)).first(adapter: adapter)
<%= ind %>  end

<%= ind %>  sig { params(records: T::Array[<%= record_class_name %>], adapter: ::HakumiORM::Adapter::Base).void }
<%= ind %>  def self.preload_<%= assoc[:method_name] %>(records, adapter: ::HakumiORM.adapter)
<%= ind %>    return if records.empty?

<%= ind %>    ids = records.map { |r| r.<%= assoc[:pk_attr] %> }.uniq
<%= ind %>    return if ids.empty?

<%= ind %>    all_related = <%= assoc[:relation_class] %>.new.where(<%= assoc[:schema_module] %>::<%= assoc[:fk_const] %>.in_list(ids)).to_a(adapter: adapter)
<%= ind %>    indexed = T.let({}, T::Hash[<%= assoc[:pk_ruby_type] %>, <%= assoc[:record_class] %>])
<%= ind %>    all_related.each { |r| indexed[r.<%= assoc[:fk_attr] %>] = r }

<%= ind %>    records.each do |record|
<%= ind %>      related = indexed[record.<%= assoc[:pk_attr] %>]
<%= ind %>      record._preloaded_<%= assoc[:method_name] %> = related ? [related] : []
<%= ind %>    end
<%= ind %>  end
<%- end -%>
<%- has_many_through.each do |assoc| -%>
<%- if assoc[:singular] == "true" -%>

<%= ind %>  sig { params(adapter: ::HakumiORM::Adapter::Base).returns(T.nilable(<%= assoc[:target_record] %>)) }
<%= ind %>  def <%= assoc[:method_name] %>(adapter: ::HakumiORM.adapter)
<%= ind %>    sub = <%= assoc[:join_relation] %>.new
<%= ind %>      .where(<%= assoc[:join_schema] %>::<%= assoc[:join_fk_const] %>.eq(@<%= assoc[:pk_attr] %>))
<%= ind %>      .select(<%= assoc[:join_schema] %>::<%= assoc[:join_select_const] %>)
<%= ind %>      .compile(adapter.dialect)
<%= ind %>    <%= assoc[:target_relation] %>.new.where(
<%= ind %>      ::HakumiORM::SubqueryExpr.new(<%= assoc[:target_schema] %>::<%= assoc[:target_match_const] %>, :in, sub)
<%= ind %>    ).first(adapter: adapter)
<%= ind %>  end
<%- else -%>

<%= ind %>  sig { params(adapter: ::HakumiORM::Adapter::Base).returns(<%= assoc[:target_relation] %>) }
<%= ind %>  def <%= assoc[:method_name] %>(adapter: ::HakumiORM.adapter)
<%= ind %>    sub = <%= assoc[:join_relation] %>.new
<%= ind %>      .where(<%= assoc[:join_schema] %>::<%= assoc[:join_fk_const] %>.eq(@<%= assoc[:pk_attr] %>))
<%= ind %>      .select(<%= assoc[:join_schema] %>::<%= assoc[:join_select_const] %>)
<%= ind %>      .compile(adapter.dialect)
<%= ind %>    <%= assoc[:target_relation] %>.new.where(
<%= ind %>      ::HakumiORM::SubqueryExpr.new(<%= assoc[:target_schema] %>::<%= assoc[:target_match_const] %>, :in, sub)
<%= ind %>    )
<%= ind %>  end
<%- end -%>
<%- end -%>
<%- belongs_to.each do |assoc| -%>

<%- if assoc[:nullable] -%>
<%= ind %>  sig { params(adapter: ::HakumiORM::Adapter::Base).returns(T.nilable(<%= assoc[:record_class] %>)) }
<%= ind %>  def <%= assoc[:method_name] %>(adapter: ::HakumiORM.adapter)
<%= ind %>    cached = @_preloaded_<%= assoc[:method_name] %>
<%= ind %>    return cached.first if cached

<%= ind %>    fk_val = @<%= assoc[:fk_attr] %>
<%= ind %>    return nil if fk_val.nil?

<%= ind %>    <%= assoc[:record_class] %>.find(fk_val, adapter: adapter)
<%= ind %>  end
<%- else -%>
<%= ind %>  sig { params(adapter: ::HakumiORM::Adapter::Base).returns(T.nilable(<%= assoc[:record_class] %>)) }
<%= ind %>  def <%= assoc[:method_name] %>(adapter: ::HakumiORM.adapter)
<%= ind %>    cached = @_preloaded_<%= assoc[:method_name] %>
<%= ind %>    return cached.first if cached

<%= ind %>    <%= assoc[:record_class] %>.find(@<%= assoc[:fk_attr] %>, adapter: adapter)
<%= ind %>  end
<%- end -%>

<%= ind %>  sig { params(records: T::Array[<%= record_class_name %>], adapter: ::HakumiORM::Adapter::Base).void }
<%= ind %>  def self.preload_<%= assoc[:method_name] %>(records, adapter: ::HakumiORM.adapter)
<%= ind %>    return if records.empty?

<%= ind %>    fk_values = records.map { |r| r.<%= assoc[:fk_attr] %> }.compact.uniq
<%= ind %>    return if fk_values.empty?

<%= ind %>    all_related = <%= assoc[:target_relation] %>.new.where(<%= assoc[:target_schema] %>::<%= assoc[:target_pk_const] %>.in_list(fk_values)).to_a(adapter: adapter)
<%= ind %>    indexed = T.let({}, T::Hash[<%= assoc[:target_pk_type] %>, <%= assoc[:record_class] %>])
<%= ind %>    all_related.each { |r| indexed[r.<%= assoc[:target_pk_attr] %>] = r }

<%= ind %>    records.each do |record|
<%= ind %>      fk = record.<%= assoc[:fk_attr] %>
<%= ind %>      record._preloaded_<%= assoc[:method_name] %> = fk ? [indexed[fk]].compact : []
<%= ind %>    end
<%= ind %>  end
<%- end -%>
<%= ind %>end
<%- if module_name -%>
end
<%- end -%>
